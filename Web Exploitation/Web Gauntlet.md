## Challenge Description
This challenge is a filter bypass task. The application enforces an evolving blacklist of tokens across rounds. 
The objective is to bypass each round's filters and ultimately access filter.php source or another view that discloses the flag. 


## Solution
The objective is to bypass a series of progressively difficult input filters to achieve a specific application state. The application's core logic is:

Stateful Progression: The server uses a PHP session ($_SESSION['round']) to track our progress. This requires all malicious payloads to be sent within the same browser session (or with a script that properly manages session cookies).

Vulnerable Backend: The backend almost certainly constructs a SQL query by directly embedding user input (e.g., username) into a query string. This is a classic SQL Injection (SQLi) vulnerability.

Evolving Blacklist: Each time we successfully bypass a round, the application adds new "bad" strings (like '--', '/*', 'admin') to a blacklist ($filter array). Our goal is to craft a payload that is syntactically valid for the SQL database but does not contain any of the currently blacklisted substrings.

The Goal: The application logic (visible in filter.php) contains a condition. Once $_SESSION['round'] reaches a high enough number (e.g., 6 or more), it stops processing the login and instead calls highlight_file("filter.php").

Final Exploit: Our goal is to chain together enough bypasses to increment the "round" counter until we trigger this highlight_file call, which will disclose the server-side source code, including the flag hidden within its comments.

## Steps
Here is the step-by-step bypass process, analyzing the filter at each stage.

Round 1: Baseline SQLi Probe
The initial filter is minimal or non-existent. We start with the most common SQLi payload to test for the vulnerability.

Payload: admin' --

(Note the trailing space after -- which is required by some SQL dialects).

How it Works:

admin : Provides the username the application is likely checking for.

' : This single quote closes the string literal in the SQL query. The backend query is likely ... WHERE username = '{$_POST['username']}' ..., so our quote turns it into ... WHERE username = 'admin' ....

-- : This is a SQL line comment. It instructs the database to ignore the rest of the query. This effectively comments out the part of the query that would check the password, (e.g., ... AND password = '...').

Result: The server accepts this payload, the logic for "admin" succeeds without a valid password, and we advance to the next round.

Round 2: Bypassing the First Filter
The server now adds '--' to its blacklist. Our first payload is blocked. We must test for an alternative SQL comment syntax.

Payload: admin' /*

How it Works:

'/*' is the syntax for a multi-line block comment in SQL. It functions identically to --, commenting out the remainder of the query.

The developers only blacklisted -- and forgot to also block /*. This is a common and fatal flaw in blacklist design.

Result: The payload is not on the blacklist, the SQL injection works, and we advance again.

Round 3: Encountering Stricter Filters
At this stage, the $filter array has expanded. Payloads like admin' -- and admin' /* are now rejected as "Invalid username/password." 
This feedback confirms our payloads (or parts of them) are on the blacklist. We now need to bypass filters that are likely targeting the username itself.

Payload : admin'/**//*

Round 4 & 5: Obfuscation via Token Splitting
The filter now almost certainly blocks the literal string "admin". The bypass is to construct the string 'admin' on the database side using functions or operators that the PHP filter doesn't block.

Payload: adm'||'in'/**//*

How it Works:

This payload uses the SQL string concatenation operator (||). (Note: Other dialects use + or the CONCAT() function).

adm' : This closes the first part of the string.

|| 'in' : This tells the database to concatenate the string 'adm' with the string 'in'. The database computes this before running the WHERE clause, so it ends up comparing the username column to the resulting string: 'admin'.


Why it Bypasses: The PHP script scans our input for the substring "admin". Our payload adm' || 'in' -- does not contain this literal string. The filter sees 'adm', '||', 'in', and '--', all of which may be "safe" individually. The database, however, sees a valid command.

Final Step: Source Code Disclosure
After successfully chaining these bypasses, $_SESSION['round'] is incremented past the final check. The application's if condition for the login is no longer met, and it falls through to the debug/disclosure function.

Triggered Code: highlight_file("filter.php");

Result: The server responds not with the login page, but with the full, color-highlighted PHP source code for filter.php.

Flag: We read the source code and find the flag (e.g., picoCTF{y0u_m4d3_1t_79a0ddc6}) hidden in a PHP comment (// or /* ... */) at the bottom of the file.

## Flag
```
// picoCTF{y0u_m4d3_1t_79a0ddc6}
```
## Concepts Learnt
Blacklist Filtering is Fundamentally Flawed: This challenge is the canonical example of why blacklisting is a failed security strategy. It's an impossible cat-and-mouse game. The attacker only needs to find one bypass, while the defender must predict all possible bypasses (encodings, different syntaxes, obfuscation, etc.).

Whitelist vs. Blacklist:

Blacklist (This Challenge): Defines what is not allowed (e.g., block: '--', '/*', 'admin'). Everything else is permitted.

Whitelist (Secure): Defines what is allowed (e.g., allow: a-z, 0-9, _). Everything else is rejected. A strict whitelist for the username would have prevented this entire attack.

The True Solution: Parameterized Queries (Prepared Statements):

The root cause is mixing code (the SELECT statement) with data (the username).

Prepared Statements send the query template to the database first (e.g., SELECT * FROM users WHERE username = ?).

Then, it sends the user's data (admin' -- ) separately. The database never executes the data; it only uses it as a value for the ? parameter. This makes SQLi impossible.

Stateful Web Exploitation: Many CTFs require managing a session. The server uses the PHPSESSID cookie (or similar) to link your requests to your $_SESSION data on the server. If you use a script, you must use a session object (like requests.Session in Python) to automatically capture and resend this cookie with every request.

Information Disclosure via Debug Functions: Developers often leave debug functions in production code. Any function that can read and display files from the server is a high-severity vulnerability.

Functions to look for: highlight_file(), show_source() (an alias), file_get_contents(), readfile(), fopen(), include().

## Notes 
Scripting the Attack: This challenge is ideal for automation. You would use a requests.Session in Python to maintain the session cookie.

```python

import requests

# URL of the challenge
url = "http://shape-facility.picoctf.net:63293/"

# Payloads for each round, in order
payloads = [
    "admin' -- ",
    "admin' /*",
    "adm' || 'in' -- ",
    # ... add more as needed, e.g., "ad' || 'min' /*"
]

# Use a Session object to persist cookies
s = requests.Session()

# Send the first request to get a session
s.get(url)

for payload in payloads:
    print(f"[*] Sending payload: {payload}")
    form_data = {
        "username": payload,
        "password": "password" # Password doesn't matter
    }

    # Send the POST request with our payload
    r = s.post(url, data=form_data)

    # Check if we triggered the flag
    if "picoCTF{" in r.text:
        print(f"[+] Flag found in response!")
        print(r.text)
        break

    # Check if the round advanced (logic depends on server response)
    if "Congrats" in r.text or "Round" in r.text:
         print("[+] Round advanced!")
    else:
         print("[-] Payload failed or was blocked.")
```

Other Filter Evasion Techniques: This challenge was simple, but in the real world, filters are bypassed with more advanced techniques:

Encoding: Double URL encoding (%2527 for '), Hex (0x61646d696e for 'admin'), etc.

Case Insensitivity: If the filter is str_replace("admin", ...) (case-sensitive), a payload like aDmIn' -- would bypass it.

Whitespace & Comments: Using tabs, newlines, or inline comments to split keywords. Example: SEL/**/ECT * F/**/ROM users...

Alternative Syntax: Using CONCAT('adm','in') instead of ||.

Null Bytes: admin%00' -- . In some weak C-based backends, the %00 (null byte) can terminate the string in the filter's code, but not in the database's code, leading to a bypass.

Resources

1. https://owasp.org/www-community/attacks/SQL_Injection

2. https://portswigger.net/web-security/sql-injection/cheat-sheet

3. https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html
