# Challenge Description
Smash the stack! Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here. And connect with it using nc saturn.picoctf.net 65362

The program reads user input into a buffer clutter using the unsafe gets() function. Our goal is to overflow this buffer to overwrite an adjacent 4-byte variable named code with the specific value 0xdeadbeef, bypassing a security check and printing the flag.

## Solution:
This challenge is an example of a stack buffer overflow that targets a local variable rather than the return address.
Step 1: Initial Analysis of the Code
First, I downloaded and examined the source code. Analyzing the binary reveals a main function with logic similar to this:
```
void main(void) {
  char clutter[76]; // Buffer size is 76 bytes
  int code;

  code = 0; // Variable is initialized
  gets(clutter); // Unsafe function reads input

  if (code == 0xdeadbeef) {
    print_flag(); // Our goal
  } else {
    printf("Wrong code\n");
  }
}
```

Vulnerability: The function gets() is notoriously insecure because it does not perform any bounds checking. It will continue writing input to the clutter buffer until it receives a newline, overflowing onto adjacent stack memory.

Stack Layout: Local variables are typically laid out sequentially on the stack. In this 64-bit binary, the clutter buffer is placed on the stack, and the code variable is placed immediately after it in memory.

Exploit Plan: Our payload must be a single string that fills the clutter buffer completely and then "spills over" to overwrite the code variable.

Padding: We need exactly 76 bytes of "junk" data to fill the clutter buffer.

Value: Immediately following the junk, we must provide the 4-byte value 0xdeadbeef.

Endianness: Since x86-64 systems are little-endian, the multi-byte value 0xdeadbeef must be written in reverse byte order: \xef\xbe\xad\xde.

Here is a new write-up for "clutter-overflow," formatted in the same detailed style.

Challenge Breakdown: clutter-overflow
Category: Binary Exploitation (pwn) Vulnerability: Stack Buffer Overflow (Variable Overwrite) Goal: The program reads user input into a buffer clutter using the unsafe gets() function. Our goal is to overflow this buffer to overwrite an adjacent 4-byte variable named code with the specific value 0xdeadbeef, bypassing a security check and printing the flag.

Strategic Analysis
This challenge is a classic example of a stack buffer overflow that targets a local variable rather than the return address.

Source Code / Decompilation: Analyzing the binary (e.g., in Ghidra) reveals a main function with logic similar to this:

C

void main(void) {
  char clutter[76]; // Buffer size is 76 bytes
  int code;

  code = 0; // Variable is initialized
  gets(clutter); // Unsafe function reads input

  if (code == 0xdeadbeef) {
    print_flag(); // Our goal
  } else {
    printf("Wrong code\n");
  }
}
Vulnerability: The function gets() is notoriously insecure because it does not perform any bounds checking. It will continue writing input to the clutter buffer until it receives a newline, overflowing onto adjacent stack memory.

Stack Layout: Local variables are typically laid out sequentially on the stack. In this 64-bit binary, the clutter buffer is placed on the stack, and the code variable is placed immediately after it in memory.

Exploit Plan: Our payload must be a single string that fills the clutter buffer completely and then "spills over" to overwrite the code variable.

Padding: We need exactly 76 bytes of "junk" data to fill the clutter buffer.

Value: Immediately following the junk, we must provide the 4-byte value 0xdeadbeef.

Endianness: Since x86-64 systems are little-endian, the multi-byte value 0xdeadbeef must be written in reverse byte order: \xef\xbe\xad\xde.
## Steps
1. Determining the Offset
Static analysis with Ghidra or dynamic analysis with gdb is used to find the exact size of the clutter buffer.

In Ghidra, the decompiler shows clutter is 76 bytes (e.g., at stack offset rbp-0x50) and code is 4 bytes (e.g., at rbp-0x4). The distance from the start of clutter to the start of code is 0x50 - 0x4 = 0x4c, which is 76 bytes in decimal.

Alternatively, using pwntools-gdb and a De Bruijn sequence (cyclic(100)) would show that the code variable (or rbp-0x4) is overwritten after 76 bytes.

2. Crafting the Payload
The payload will be [76 bytes of padding] + [4-byte value]. We can use Python to construct this.

```python

import struct

# 1. Padding: 76 'A' characters
# We use 'b' to create a byte string
padding = b'A' * 76

# 2. Value: 0xdeadbeef
# We use struct.pack with '<I' to pack it as a
# 4-byte (<I) little-endian (<) unsigned integer.
value = struct.pack('<I', 0xdeadbeef)
# This is equivalent to b'\xef\xbe\xad\xde'

# 3. Final Payload
payload = padding + value
```
3. Executing the Exploit
We send this payload to the remote server using a pipe. The gets() function on the server will read our payload, overflow the clutter buffer, and set the code variable to 0xdeadbeef. The if condition will then pass, and the server will execute print_flag(), sending the flag back to us.


```python

# We use python3 -c "..." to print the raw bytes of our payload
# Note: We must use sys.stdout.buffer.write() to send raw bytes,
# as print() can mangle them.

python3 -c "import sys, struct; padding = b'A' * 76; value = struct.pack('<I', 0xdeadbeef); sys.stdout.buffer.write(padding + value)"
Full exploit pipe:

```

(python3 -c "import sys, struct; padding = b'A' * 76; value = struct.pack('<I', 0xdeadbeef); sys.stdout.buffer.write(padding + value)") | nc saturn.picoctf.net [PORT]
Flag
(The flag would be printed to the console.)

## Flag:
```
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```
## Concepts Learnt
Stack Buffer Overflow: The fundamental vulnerability where writing to a buffer on the stack exceeds its allocated bounds.

Unsafe C Functions (gets): A clear demonstration of why gets() was deprecated and is extremely dangerous. It has no mechanism to prevent overflows. fgets() is the safe alternative.

Stack Frame Layout: A deeper understanding of how a function's local variables are organized in memory. In this case, they were adjacent, allowing one to overwrite the other.

Data vs. Control Flow Attacks: This was a data-oriented attack. We didn't hijack the program's control flow (by overwriting a return address); we corrupted its data (the code variable) to trick its existing logic.

Endianness (Little-Endian): A critical concept in binary exploitation. Multi-byte numbers like integers (0xdeadbeef) are stored with the least-significant byte (ef) first in memory on x86/x64 systems. Our payload must match this format.

## Notes
Finding the Offset: The most common method for finding offsets in "pwn" challenges is using a De Bruijn sequence, or a "cyclic pattern," generated by pwntools. You send cyclic(100), let the program crash, and then see what value (e.g., 0x6161616a) overwrote the target. cyclic_find(0x6161616a) would then tell you the exact offset (e.g., 76).

Static vs. Dynamic Analysis: This problem could be solved with either.

Static (Ghidra/IDA): Decompiling the binary and reading the stack offsets. This is fast and reliable.

Dynamic (GDB): Running the program and probing it with different-sized inputs until the desired overwrite occurs.

pwn vs. struct: The pwntools Python library simplifies this. p32(0xdeadbeef) is the pwntools equivalent of struct.pack('<I', 0xdeadbeef) and is the standard for CTF players.

## Resources:
1. https://ghidra-sre.org/
2. https://github.com/Gallopsled/pwntools
3. https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN
4. https://www.youtube.com/watch?v=CRTR5ljBjPM

